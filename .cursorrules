# Instructions

During you interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name), especially about a fix to a mistake you made or a correction you received, you should take note in the `Lessons` section in the `.cursorrules` file so you will not make the same mistake again.

You should also use the `.cursorrules` file as a scratchpad to organize your thoughts. Especially when you receive a new task, you should first review the content of the scratchpad, clear old different task if necessary, first explain the task, and plan the steps you need to take to complete the task. You can use todo markers to indicate the progress, e.g.
[X] Task 1
[ ] Task 2

Also update the progress of the task in the Scratchpad when you finish a subtask.
Especially when you finished a milestone, it will help to improve your depth of task accomplishment to use the scratchpad to reflect and plan.
The goal is to help you maintain a big picture as well as the progress of the task. Always refer to the Scratchpad when you plan the next step.

# MCP Server Tools Usage

## Strategic Tool Selection

- **Sequential Thinking:**
  - Use for multi-step operations requiring careful planning.
  - Maintain operational context to enable course correction.
  - Begin with a higher number of total thoughts (e.g. 8–12) for complex tasks.
  - Use branching to explore alternative approaches and mark revisions when needed.
  - Set `needsMoreThoughts=true` when new complexities arise.

- **Web Research (via Brave Search):**
  - Always conduct initial broad searches, then follow with detailed research.
  - Validate technical approaches, error handling strategies, and best practices.
  - Cross-reference multiple reputable sources before implementation.

- **Puppeteer Operations:**
  - Use for intricate web interactions and testing.
  - Implement chained operations with robust error handling, waits, and retries.
  - Optimise memory by closing pages when done and reusing browser instances.

- **Server Memory (Knowledge Graph):**
  - Maintain complex relationships and operational context.
  - Create entities for major components and concepts.
  - Map dependencies and document architectural decisions.
  - Regularly clean up obsolete entities and update relationships.

- **Memory (@itseasy21\mcp-knowledge-graph):**
  - Start with "Remembering..." and read what you stored in memory before working on a task
  - Reference knowledge as "memory"
  - When the assigned task is done:
    1. Create/update entities
    2. Define relationships
    3. Store observations

- **Firecrawl MCP:**
  - Use for advanced web crawling and data extraction tasks.
  - Efficiently navigate complex websites and extract structured data.
  - Handle pagination, authentication, and dynamic content loading.
  - Process and transform extracted data for integration with other systems.

### Sequential Thinking
- Use for operations requiring multiple steps
- Essential for maintaining operational context
- Helps break down large changes into manageable chunks
- Enables course correction and revision of approach
- Key usage patterns:
  * Start with higher total_thoughts for complex tasks (8-12)
  * Use branching for exploring alternative approaches
  * Mark revisions when changing previous decisions
  * Set needsMoreThoughts=true when discovering new complexity
  * Use as tactical memory during long operations

### Web Research (Brave Search)
- Always search before implementing complex features
- Research patterns:
  * Start with broad concept search
  * Follow up with specific implementation details
  * Look for recent discussions and solutions
  * Cross-reference multiple sources
  * Use for validating approach before major changes
- Key usage:
  * Technical implementation patterns
  * Error handling strategies
  * Best practices validation
  * Community solutions to similar problems

### Puppeteer Operations
- Use for complex web interactions and testing
- Strategic patterns:
  * Chain operations with proper error handling
  * Use screenshots for validation points
  * Implement waits and retries for stability
  * Maintain session context across operations
- Memory management:
  * Close pages when done
  * Reuse browser instances when possible
  * Clear large objects after operations
  * Monitor memory usage in long sessions

### Memory Management
- Start with "Remembering..." and read what you stored in memory before working on a task
- Reference knowledge as "memory"
- When the assigned task is done:
  1. Create/update entities
  2. Define relationships
  3. Store observations

### Firecrawl Operations
- Use for comprehensive web data extraction
- Strategic patterns:
  * Define clear extraction targets and selectors
  * Handle site navigation and state management
  * Process and transform extracted data
  * Implement error recovery and retry mechanisms
- Best practices:
  * Respect website terms of service and robots.txt
  * Implement rate limiting to avoid overloading servers
  * Store extracted data efficiently
  * Validate data integrity after extraction

## Operational Guidelines

### For Moderate Changes (30-100 lines):
1. Start with sequential thinking (5-8 thoughts)
2. Research similar implementations
3. Plan key validation points
4. Execute with regular state checks

### For Large Changes (100+ lines):
1. Begin with comprehensive sequential thinking (10+ thoughts)
2. Extensive research phase
3. Break into sub-operations
4. Regular validation checkpoints
5. Maintain operational memory through scratchpad

# Lessons

- When converting to n8n Object format, results should be returned directly in the `json` property without wrapping them in a `convertedData` field to maintain a cleaner output format
- For n8n Object output, if the result is an array with a single item, we should return just that item rather than the array
- For other output formats (HTML, CSV, JSON), the result should be wrapped in the specified `outputField` (default: "convertedData")

# Scratchpad

# CSV JSON HTMLTable Converter - Format Conversions Documentation

## Conversion Combinations and UI Options

### HTML → HTML
- **UI Parameters Available**:
  - selectorMode: 'simple' or 'advanced'
  - tablePreset (when selectorMode = 'simple'): Various options for table selection
  - tableSelector: CSS selector for tables (if selectorMode = 'advanced' or tablePreset = 'custom')
  - elementSelector: CSS selector for containing elements (if selectorMode = 'advanced')
  - headingLevel: 'h1' to 'h6' (if tablePreset = 'table-under-heading')
  - headingText: Text to match (if tablePreset = 'table-under-heading')
  - tableIndex: Which table to select (if tablePreset = 'table-under-heading')
  - includeTableHeaders: Whether to include headers
  - prettyPrint: Whether to format HTML with indentation
  - outputField: Field name in output
  - multipleItems: Whether to process multiple items
- **Actual Implementation**:
  - Calls htmlToHtml
  - All UI parameters are used as specified

### HTML → CSV
- **UI Parameters Available**:
  - selectorMode, tablePreset, tableSelector, elementSelector, headingLevel, headingText, tableIndex (same as HTML → HTML)
  - csvDelimiterOutput: Character used as delimiter in CSV output
  - outputField: Field name in output
  - multipleItems: Whether to process multiple items
- **Actual Implementation**:
  - Uses htmlToCsv
  - All UI parameters are used as specified

### HTML → JSON
- **UI Parameters Available**:
  - selectorMode, tablePreset, tableSelector, elementSelector, headingLevel, headingText, tableIndex (same as HTML → HTML)
  - prettyPrint: Whether to format JSON with indentation
  - outputField: Field name in output
  - multipleItems: Whether to process multiple items
- **Actual Implementation**:
  - Uses htmlToJson
  - All UI parameters are used as specified



### HTML → n8nObject
- **UI Parameters Available**:
  - selectorMode, tablePreset, tableSelector, elementSelector, headingLevel, headingText, tableIndex (same as HTML → HTML)
  - outputField: Field name in output
  - multipleItems: Whether to process multiple items
- **Actual Implementation**:
  - Uses htmlToJson internally and parses the result
  - includeTableHeaders is hardcoded to true regardless of UI setting
  - Result is directly converted to JavaScript object

### CSV → HTML
- **UI Parameters Available**:
  - csvDelimiterInput: Character used to separate CSV values
  - includeTableHeaders: Whether to include headers in HTML table
  - prettyPrint: Whether to format HTML with indentation
  - outputField: Field name in output
  - multipleItems: Whether to process multiple items
- **Actual Implementation**:
  - Uses csvToHtml
  - All UI parameters are used as specified

### CSV → CSV
- **UI Parameters Available**:
  - csvDelimiterInput: Character for input CSV
  - csvDelimiterOutput: Character for output CSV
  - outputField: Field name in output
  - multipleItems: Whether to process multiple items
- **Actual Implementation**:
  - Returns data as is (same format)
  - includeTableHeaders is hardcoded to true regardless of UI setting

### CSV → JSON
- **UI Parameters Available**:
  - csvDelimiterInput: Character for CSV input
  - prettyPrint: Whether to format JSON with indentation
  - outputField: Field name in output
  - multipleItems: Whether to process multiple items
- **Actual Implementation**:
  - Uses csvToJson
  - includeTableHeaders is hardcoded to true regardless of UI setting
  - All other UI parameters are used as specified

### CSV → n8nObject
- **UI Parameters Available**:
  - csvDelimiterInput: Character for CSV input
  - outputField: Field name in output
  - multipleItems: Whether to process multiple items
- **Actual Implementation**:
  - Uses csvToJson internally and parses the result
  - includeTableHeaders is hardcoded to true regardless of UI setting
  - Result is directly converted to JavaScript object

### JSON → HTML
- **UI Parameters Available**:
  - includeTableHeaders: Whether to include headers in HTML table
  - prettyPrint: Whether to format HTML with indentation
  - outputField: Field name in output
  - multipleItems: Whether to process multiple items
- **Actual Implementation**:
  - Uses jsonToHtml
  - All UI parameters are used as specified

### JSON → CSV
- **UI Parameters Available**:
  - csvDelimiterOutput: Character for output CSV
  - outputField: Field name in output
  - multipleItems: Whether to process multiple items
- **Actual Implementation**:
  - Uses jsonToCsv
  - includeTableHeaders is hardcoded to true regardless of UI setting
  - All other UI parameters are used as specified

### JSON → JSON
- **UI Parameters Available**:
  - prettyPrint: Whether to format JSON with indentation
  - outputField: Field name in output
  - multipleItems: Whether to process multiple items
- **Actual Implementation**:
  - Returns data as is (same format)
  - All UI parameters are used as specified

### JSON → n8nObject
- **UI Parameters Available**:
  - outputField: Field name in output
  - multipleItems: Whether to process multiple items
- **Actual Implementation**:
  - Uses JSON.parse to convert JSON string to object
  - Result is directly returned as JavaScript object

### n8nObject → HTML
- **UI Parameters Available**:
  - includeTableHeaders: Whether to include headers in HTML table
  - prettyPrint: Whether to format HTML with indentation
  - outputField: Field name in output
- **Actual Implementation**:
  - Uses jsonToHtml
  - multipleItems is hardcoded to false regardless of UI setting
  - All other UI parameters are used as specified
  - Special handling: Always combines all items into one array for processing

### n8nObject → CSV
- **UI Parameters Available**:
  - csvDelimiterOutput: Character for output CSV
  - outputField: Field name in output
  - prettyPrint: Whether to format CSV output
- **Actual Implementation**:
  - Uses PapaParse directly
  - includeTableHeaders is hardcoded to true regardless of UI setting
  - multipleItems is hardcoded to false regardless of UI setting
  - Special handling: Always combines all items into one array for processing

### n8nObject → JSON
- **UI Parameters Available**:
  - prettyPrint: Whether to format JSON with indentation
  - outputField: Field name in output
- **Actual Implementation**:
  - Uses JSON.stringify
  - multipleItems is hardcoded to false regardless of UI setting
  - Special handling: Always combines all items into one array for processing

### n8nObject → n8nObject
- **UI Parameters Available**:
  - outputField: Field name in output
- **Actual Implementation**:
  - Returns object as is
  - multipleItems is hardcoded to false regardless of UI setting

## Key Patterns and Issues

1. **Special Output Handling**:
   - For n8nObject output: Results should be returned directly in the `json` property without wrapping in a `convertedData` field
   - For other formats (HTML, CSV, JSON): Results should be wrapped in the specified `outputField` (default: "convertedData")
   - For n8nObject output with single item arrays, the single item should be returned rather than the array

2. **UI Parameter Consistency Issues**:
   - includeTableHeaders is only used for HTML target format except when source is n8nObject. For all other formats, it's hardcoded to true.
   - multipleItems is ignored for n8nObject source format, always treated as false.
   - When n8nObject is the source format and target is HTML/CSV/JSON, all items are combined into one array regardless of multipleItems setting.

3. **Special Cases**:
   - HTML → HTML: Uses special htmlToHtml function instead of simply returning data
   - JSON → n8nObject: Uses JSON.parse instead of simply returning data
   - n8nObject → HTML/CSV/JSON: Special handling to collect all items into one array

4. **Potential Bugs/Inconsistencies**:
   - When converting to n8nObject, results should be returned directly in the json property without additional wrapping
   - For n8nObject output with single item arrays, the behavior might be inconsistent with some code assuming arrays and others expecting individual items
   - The handling of includeTableHeaders and multipleItems parameters is inconsistent across different conversion combinations
